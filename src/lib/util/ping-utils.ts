import _ from "underscore"
import { GuildMember, GuildMemberRoleManager, Snowflake } from "discord.js"
import { member, message, pingChannel, preferredName, valRole } from "../util/discord-utils"
import { Ping } from "../../config/firestore-schema"
import { nameToEmoji, numToEmoji, readableArray, readableTimeMinutes } from "../util/data-structure-utils"
import { fetchPing, markFired, setMessageId, setResponseMessageId } from "../firestore/pings"

// Helper for generating ping text
async function buildBaseText(ping: Ping) {
    const pinger = await member(ping.requesterId)
    const role = await valRole(pinger)

    const modeString = ping.mode ? ` (**${ping.mode}**)` : ""
    return `${preferredName(pinger)} - ${role}${modeString}`
}

// Helper for generating delay message text
async function buildDelayText(ping: Ping) {
    if (!_.isUndefined(ping.delayLeft)) {
        const pinger = await member(ping.requesterId)
        const suffix = ping.delayLeft > 0 ? `in **${readableTimeMinutes(ping.delayLeft)}**. ${nameToEmoji("eyes")}` : `**now** (ping is below). ${nameToEmoji("tada")}`
        return `${preferredName(pinger)} wants to play ${suffix}`
    } else {
        throw Error(`Cannot build delay text as ping has no set delay: ${ping}`)
    }
}

// Ping gamers
export async function firePing(ping: Ping) {
    const pinger = await member(ping.requesterId)
    const role = await valRole(pinger)
    const channel = await pingChannel(pinger)

    // Temporarily remove member from the gaming role to avoid pinging the caller
    const memberRoles = pinger.roles as GuildMemberRoleManager
    const isGamer = memberRoles.cache.has(role.id)
    await memberRoles.remove(role)

    // Send message
    const baseText = await buildBaseText(ping)
    const message = await channel.send(baseText)
    await setMessageId(ping.pingId, message.id)

    // Update ping, mark as fired
    await markFired(ping.pingId)

    // If removed from the gaming role, add them back
    if (isGamer) memberRoles.add(role)
}

// Update message (for TTL)
export async function updateTtl(pingId: Snowflake) {
    const ping = (await fetchPing(pingId))!
    if (!ping.messageId) throw Error(`Update TTL failed - no message ID in ${ping}`)
    const baseText = await buildBaseText(ping)

    if (!_.isUndefined(ping.ttlLeft)) {
        const pinger = await member(ping.requesterId)
        const pingMessage = await message(await pingChannel(pinger), ping.messageId)

        if (ping.ttlLeft > 0) {
            const suffix = ` (expires in **${readableTimeMinutes(ping.ttlLeft)}**)`
            await pingMessage.edit(baseText + suffix)
        } else {
            await pingMessage.edit(`~~${baseText}~~ [EXPIRED]`)
        }
    } else {
        console.log(`Skipping ping message update as TTL is not set: ${ping}`)
    }
}

// Send delay message
export async function sendDelay(ping: Ping) {
    if (ping.messageId || ping.fired) throw Error(`Cannot send delay for: ${ping}`)

    const pinger = await member(ping.requesterId)
    const channel = await pingChannel(pinger)
    const delayMessage = await channel.send(await buildDelayText(ping))
    delayMessage.pin().then(async _ => {
        // Find the autogenerated "x pinned a message..."
        const test = await channel.messages.fetch({ limit: 5 })
        for (const [_, message] of test) {
            if (message.type === "CHANNEL_PINNED_MESSAGE") {
                // ...and delete it
                message.delete()
            }
        }
    })

    await setMessageId(ping.pingId, delayMessage.id)
}

// Update delay message
export async function updateDelay(pingId: Snowflake) {
    const ping = (await fetchPing(pingId))!
    if (!ping.messageId) throw Error(`Update delay failed - no message ID in ${ping}`)
    if (ping.fired) throw Error(`Cannot update delay of a ping that is fired: ${ping}`)

    const pinger = await member(ping.requesterId)
    if (!_.isUndefined(ping.delayLeft)) {
        const delayMessage = await message(await pingChannel(pinger), ping.messageId!)
        await delayMessage.edit(await buildDelayText(ping))

        // Unpin delay message if delay has just completed
        if (ping.delayLeft <= 0) delayMessage.unpin()
    } else {
        console.log(`Skipping delay message update as delay is not set: ${ping}`)
    }
}

// Update response message
export async function updateResponseMessage(pingId: Snowflake, pinger?: GuildMember) {
    const ping = (await fetchPing(pingId))!
    if (_.isEmpty(ping.responses)) throw Error(`Response array is empty for ping ${pingId}`)
    if (!ping.fired) throw Error("Ping must be fired to have responses.")

    pinger ??= await member(ping.requesterId)

    // Update the response string (or send it)
    const channel = await pingChannel(pinger)
    const pingMessage = await message(channel, ping.messageId!)
    const responderString = readableArray(await Promise.all(ping.responses.map(async memberId => preferredName(await member(memberId)))))
    const newResponseText = `${responderString} ${ping.responses.length === 1 ? "is" : "are"} down`

    if (ping.responseMessageId) {
        const responseMessage = await message(channel, ping.responseMessageId)
        await responseMessage.edit(newResponseText)
    } else {
        const pingMessage = await message(channel, ping.messageId!)
        const responseMessage = await pingMessage.reply(newResponseText)

        // Track newly sent response message
        await setResponseMessageId(ping.pingId, responseMessage.id)
    }

    // Update reacts to the ping message
    await pingMessage.reactions.removeAll()
    for (const emoji of numToEmoji(ping.responses.length + 1)) {
        await pingMessage.react(emoji)
    }
}